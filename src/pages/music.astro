---
import Base from "../layouts/Base.astro";
export const prerender = false;
---

<Base
  title="Music ‚Äî RadioABF"
  description="Live history, covers and weekly community votes on RadioABF."
  canonical="/music"
  image="/og-image.jpg"
>
  <!-- ‚úÖ ROOT WRAPPER (avoid ID collisions with pinned player) -->
  <div id="musicPageRoot">
    <!-- HERO -->
    <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-[#0A1F33] p-6 md:p-8 shadow-2xl">
      <div class="pointer-events-none absolute -top-40 -left-40 w-[600px] h-[600px] bg-cyan-500/20 rounded-full blur-[120px]"></div>
      <div class="pointer-events-none absolute -bottom-40 -right-40 w-[600px] h-[600px] bg-blue-600/20 rounded-full blur-[120px]"></div>

      <div class="relative z-10">
        <div class="flex items-center gap-3 text-sm tracking-widest text-white/60 uppercase mb-3">
          <span class="w-2 h-2 bg-cyan-400 rounded-full animate-pulse"></span>
          Music portal
        </div>

        <!-- ‚úÖ Premium header layout (title aligned to top) -->
        <div class="grid grid-cols-1 lg:grid-cols-[minmax(0,1fr)_420px] gap-5 lg:items-start">
          <div class="min-w-0">
            <!-- ‚úÖ ABF-ish title with cyan ending + more community/music/charts oriented -->
            <h1 class="text-3xl md:text-4xl font-extrabold leading-tight">
              Community Music, Radio & <span class="text-cyan-200">Charts</span>
            </h1>
            <p class="mt-3 text-white/65 max-w-2xl whitespace-normal">
              Clean metadata + community voting (1 vote / track / day). Covers: Directus-first when you upload, iTunes fallback when needed.
            </p>
          </div>

          <!-- Right column -->
          <div class="min-w-0">
            <!-- ‚úÖ 3 badges ALWAYS on one line -->
            <div class="flex items-center justify-start lg:justify-end gap-2 flex-nowrap overflow-x-auto no-scrollbar">
              <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-2 rounded-xl flex-none">
                Vote: 1 / track / day
              </span>
              <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-2 rounded-xl flex-none">
                Covers: Directus ‚Üí iTunes
              </span>
              <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-2 rounded-xl flex-none">
                Updates every 8s
              </span>
            </div>

            <!-- Search widget -->
            <div class="mt-3 rounded-2xl border border-white/10 bg-white/5 p-3 sm:p-4">
              <div class="flex items-center justify-between gap-3">
                <div class="text-xs text-white/60 uppercase tracking-wider">Search air time</div>
                <div class="text-xs text-white/45">Closest match</div>
              </div>

              <div class="mt-2 grid grid-cols-1 sm:grid-cols-[1fr_120px_auto] gap-2">
                <input id="airDate" type="date" class="abfInput" aria-label="Air date" />
                <input id="airTime" type="time" class="abfInput" aria-label="Air time" />
                <button id="airSearchBtn" type="button" class="abfBtn">Find</button>
              </div>

              <div id="airSearchResult" class="mt-3 hidden"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- PORTAL GRID -->
    <section class="mt-8 grid grid-cols-1 xl:grid-cols-[minmax(0,1fr)_minmax(0,0.85fr)] gap-6 items-start">
      <!-- LEFT -->
      <div class="rounded-3xl border border-white/10 bg-[#0A1F33] overflow-hidden shadow-xl">
        <div class="p-5 md:p-6 border-b border-white/10">
          <div class="flex items-center justify-between gap-4 flex-wrap">
            <div class="min-w-0">
              <div class="text-sm text-white/60 uppercase tracking-wider">Now playing</div>
              <div class="text-xs text-white/50 mt-1">Live metadata ‚Ä¢ clean titles ‚Ä¢ vote enabled</div>
            </div>

            <!-- ‚úÖ Badges order EXACTLY: LIVE ‚Üí COVER ‚Üí TIME -->
            <div class="flex items-center gap-2">
              <div
                id="npLiveBadge"
                class="inline-flex items-center gap-2 px-3 py-1.5 rounded-full bg-red-500/15 border border-red-500/25 text-red-200 text-xs font-semibold tracking-wider"
              >
                <span class="w-2 h-2 rounded-full bg-red-400 animate-pulse"></span>
                LIVE
              </div>

              <div
                id="npCoverSource"
                class="hidden inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-semibold border tabular-nums"
                aria-label="Cover source"
              >
                ‚Äî
              </div>

              <div
                id="npTimeBadge"
                class="inline-flex items-center gap-2 px-3 py-1.5 rounded-full bg-cyan-500/10 border border-cyan-400/20 text-cyan-200 text-xs font-semibold tabular-nums"
                aria-label="Now playing time"
              >
                <span class="w-2 h-2 rounded-full bg-cyan-300/80"></span>
                <span id="musicTime">--:--</span>
              </div>
            </div>
          </div>

          <!-- NOW PLAYING CARD -->
          <div class="mt-5 rounded-3xl border border-white/10 bg-white/5 overflow-hidden">
            <div class="p-4 md:p-5 flex flex-col sm:flex-row gap-4 items-center sm:items-stretch">
              <div class="flex-none">
                <div
                  id="musicCoverWrapper"
                  class="abfCover w-24 h-24 md:w-28 md:h-28 rounded-2xl border border-white/10 overflow-hidden shadow-xl bg-black/20"
                >
                  <img id="musicCover" class="hidden w-full h-full object-cover" alt="Current cover" />
                  <div class="abfCoverFallback w-full h-full grid place-items-center">
                    <img src="/logo-abf.png" alt="ABF" loading="lazy" decoding="async" class="w-16 h-16 opacity-90" />
                  </div>
                </div>
              </div>

              <div class="min-w-0 flex-1">
                <div id="musicArtist" class="text-lg md:text-xl font-extrabold text-white truncate leading-tight">‚Äî</div>
                <div id="musicTitle" class="mt-1 text-white/70 text-base md:text-lg truncate">‚Äî</div>

                <div class="mt-3 flex flex-wrap items-center gap-2">
                  <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-1.5 rounded-xl">
                    1 vote / track / day
                  </span>
                  <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-1.5 rounded-xl">
                    ABF CLUB not votable
                  </span>
                </div>
              </div>

              <!-- ‚úÖ small vote button (greys out + looks disabled after vote) -->
              <button
                id="nowVoteBtn"
                class="voteBtnMini flex-none bg-white/5 hover:bg-white/10 border border-white/10 rounded-2xl px-3 py-2 text-sm text-white/85 transition inline-flex items-center gap-2"
                type="button"
                aria-label="Vote for now playing"
              >
                üëç <span class="tabular-nums font-semibold" id="nowVoteCount">0</span>
              </button>
            </div>
          </div>
        </div>

        <!-- LAST PLAYED -->
        <div class="p-4 md:p-6">
          <div class="flex items-center justify-between gap-4 mb-4">
            <div class="text-sm text-white/60 uppercase tracking-wider">Last played</div>
            <div class="text-xs text-white/50">Tap üëç to vote</div>
          </div>

          <div
            id="historyTable"
            class="space-y-3 max-h-[70vh] xl:max-h-none overflow-y-auto scrollbar-thin scrollbar-thumb-white/20 scrollbar-track-transparent pr-1"
          ></div>

          <div id="historyEmpty" class="text-white/55 text-sm hidden">
            Start the player to load the history.
          </div>
        </div>
      </div>

      <!-- RIGHT -->
      <aside class="space-y-6">
        <!-- THIS WEEK -->
        <div class="rounded-3xl border border-white/10 bg-[#0A1F33] overflow-hidden shadow-xl">
          <div class="p-5 border-b border-white/10 flex items-start justify-between gap-4">
            <div class="min-w-0">
              <div class="text-sm text-white/60 uppercase tracking-wider">Top this week</div>
              <div class="text-xs text-white/50 mt-1">Community votes ‚Ä¢ updates in real time</div>
            </div>
            <div class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-1.5 rounded-xl flex-none">
              Week <span id="weekThis" class="tabular-nums">‚Äî</span>
            </div>
          </div>

          <div class="p-4 md:p-5">
            <ol id="topThisWeek" class="space-y-3"></ol>
            <div id="topThisEmpty" class="text-white/55 text-sm hidden">
              No votes yet ‚Äî be the first üôÇ
            </div>
          </div>
        </div>

        <!-- PREV WEEK -->
        <div class="rounded-3xl border border-white/10 bg-[#0A1F33] overflow-hidden shadow-xl">
          <div class="p-5 border-b border-white/10 flex items-start justify-between gap-4">
            <div class="min-w-0">
              <div class="text-sm text-white/60 uppercase tracking-wider">Last week</div>
              <div class="text-xs text-white/50 mt-1">Top 5 snapshot</div>
            </div>
            <div class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-1.5 rounded-xl flex-none">
              Week <span id="weekPrev" class="tabular-nums">‚Äî</span>
            </div>
          </div>

          <div class="p-4 md:p-5">
            <ol id="topPrevWeek" class="space-y-3"></ol>
            <div id="topPrevEmpty" class="text-white/55 text-sm hidden">
              No data for last week yet.
            </div>
          </div>
        </div>

        <!-- HOW IT WORKS (‚úÖ week ISO restored here) -->
        <div class="rounded-3xl border border-white/10 bg-gradient-to-br from-[#061220] via-[#0A1F33] to-[#050B14] overflow-hidden shadow-xl relative">
          <div class="pointer-events-none absolute -top-24 -right-24 w-[260px] h-[260px] bg-cyan-500/15 rounded-full blur-[90px]"></div>
          <div class="p-6 relative">
            <div class="text-xs text-white/50 uppercase tracking-wider">How it works</div>

            <div class="mt-2 flex items-center justify-between gap-3 flex-wrap">
              <div class="font-extrabold text-lg leading-tight">Voting + covers</div>
              <div class="flex items-center gap-2 text-xs">
                <span class="px-3 py-1.5 rounded-xl border border-white/10 bg-white/5 text-white/75">
                  Current <span id="howWeekThis" class="tabular-nums">‚Äî</span>
                </span>
                <span class="px-3 py-1.5 rounded-xl border border-white/10 bg-white/5 text-white/75">
                  Last <span id="howWeekPrev" class="tabular-nums">‚Äî</span>
                </span>
              </div>
            </div>

            <ul class="mt-3 text-sm text-white/70 leading-relaxed space-y-2">
              <li class="flex gap-2">
                <span class="text-cyan-200 font-semibold">‚Ä¢</span>
                <span><span class="text-white/85 font-semibold">1 vote</span> per <span class="text-white/85 font-semibold">track</span> per <span class="text-white/85 font-semibold">day</span>.</span>
              </li>
              <li class="flex gap-2">
                <span class="text-cyan-200 font-semibold">‚Ä¢</span>
                <span><span class="text-white/85 font-semibold">ABF CLUB</span> shows are <span class="text-white/85 font-semibold">not votable</span> (tracks only).</span>
              </li>
              <li class="flex gap-2">
                <span class="text-cyan-200 font-semibold">‚Ä¢</span>
                <span>Covers: <span class="text-white/85 font-semibold">Directus-first</span> if you uploaded one, else <span class="text-white/85 font-semibold">iTunes fallback</span>.</span>
              </li>
            </ul>

            <div class="mt-4 flex flex-wrap gap-2 text-xs">
              <span class="px-3 py-1.5 rounded-xl border border-white/10 bg-white/5 text-white/80">Fair voting</span>
              <span class="px-3 py-1.5 rounded-xl border border-white/10 bg-white/5 text-white/80">Clean titles</span>
              <span class="px-3 py-1.5 rounded-xl border border-white/10 bg-white/5 text-cyan-200">Premium portal</span>
            </div>

            <div class="mt-5">
              <a href="/" class="inline-flex items-center gap-2 text-sm text-cyan-200 hover:text-cyan-100 transition">
                Back to Home ‚Üí
              </a>
            </div>
          </div>
        </div>
      </aside>
    </section>

    <style>
      .tabular-nums { font-variant-numeric: tabular-nums; }

      .scrollbar-thin::-webkit-scrollbar { width: 6px; }
      .scrollbar-thin::-webkit-scrollbar-track { background: transparent; }
      .scrollbar-thin::-webkit-scrollbar-thumb {
        background-color: rgba(255,255,255,0.2);
        border-radius: 9999px;
      }

      .abfInput{
        appearance: none;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.06);
        color: rgba(255,255,255,0.9);
        border-radius: 14px;
        padding: 10px 12px;
        font-size: 12px;
        outline: none;
      }
      .abfInput:focus{
        border-color: rgba(47,194,255,0.35);
        box-shadow: 0 0 0 3px rgba(47,194,255,0.10);
      }
      .abfBtn{
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.06);
        color: rgba(255,255,255,0.9);
        border-radius: 14px;
        padding: 10px 14px;
        font-size: 12px;
        font-weight: 800;
        transition: 150ms ease;
      }
      .abfBtn:hover{ background: rgba(255,255,255,0.10); }

      .voteBtnMini{ white-space: nowrap; }

      /* ‚úÖ grey ‚Äúrow/card‚Äù when vote already used (visual + feels disabled) */
      .abfVotedRow{
        opacity: 0.78;
        filter: saturate(0.85);
      }
      .abfVotedRow .voteBtn,
      .voteBtnMini.is-voted{
        opacity: 0.55 !important;
        cursor: not-allowed !important;
      }

      /* nice one-line pills scroll on small */
      .no-scrollbar::-webkit-scrollbar{ display:none; }
      .no-scrollbar{ -ms-overflow-style:none; scrollbar-width:none; }
    </style>

    <script is:inline data-astro-rerun>
(() => {
  const ROUTE = "/music";
  const KEY = "__abfMusicPortal";
  const DAY = 24 * 60 * 60 * 1000;
  const HISTORY_KEY = "abf_history";

  const state = (window[KEY] = window[KEY] || {
    bound: false,
    timer: null,
    inFlight: false,
    lastRenderAt: 0,
    lastHistory: [],
    search: { date: "", time: "" },
    searchBound: false,
  });

  function isMusicRoute() { return window.location.pathname === ROUTE; }
  function getRoot() { return document.getElementById("musicPageRoot"); }
  function nowTs() { return Date.now(); }

  function getISOWeekId(d = new Date()){
    const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    const dayNum = date.getUTCDay() || 7;
    date.setUTCDate(date.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
    return `${date.getUTCFullYear()}-W${String(weekNo).padStart(2, "0")}`;
  }
  function getPrevISOWeekId(){
    const d = new Date();
    d.setDate(d.getDate() - 7);
    return getISOWeekId(d);
  }

  function esc(s){
    return String(s || "")
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }

  function fmtTime(ts){
    if (!ts) return "--:--";
    const d = new Date(ts);
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }

  function stripTitleSuffixes(input){
    let s = String(input || "").trim();
    if (!s) return "";
    const rx = /\s*[\(\[]\s*(?:(?:extended|original|radio|club|album|single|clean|explicit|short|long)\s*)?(?:mix|edit|version|remix|re\-mix|rework|bootleg|instrumental|acapella|a\s*cappella|dub|vip|remaster(?:ed)?|mono|stereo)\b[^)\]]*[\)\]]\s*/gi;
    s = s.replace(rx, " ");
    return s.replace(/\s{2,}/g, " ").trim();
  }

  function splitTrack(entry){
    const s = String(entry || "").trim().replace(/^undefined\s*-\s*/i, "");
    const idx = s.indexOf(" - ");
    if (idx === -1) return { artist: s.trim(), title: "" };
    return { artist: s.slice(0, idx).trim(), title: s.slice(idx + 3).trim() };
  }

  function normKey(artist, title){
    return (String(artist || "") + " - " + String(title || ""))
      .toLowerCase()
      .replace(/\u00A0/g, " ")
      .replace(/\s+/g, " ")
      .replace(/[‚Äú‚Äù"']/g, "")
      .trim();
  }

  function rawKey(artist, title){
    const a = String(artist || "").trim();
    const t = String(title || "").trim();
    return `${a} - ${t}`.trim();
  }

  function upperArtist(s){ return String(s || "‚Äî").trim().toUpperCase(); }

  function titleCaseEN(input){
    const s = String(input || "").trim();
    if (!s) return "‚Äî";
    const lowerWords = new Set([
      "a","an","the","and","but","or","nor","for","so","yet",
      "as","at","by","for","from","in","into","near","of","on","onto","over","per","to","up","via","with","within","without"
    ]);
    const parts = s.split(/(\s+)/);
    return parts.map((chunk, idx) => {
      if (/^\s+$/.test(chunk)) return chunk;
      const word = chunk;
      if (word === word.toUpperCase() && /[A-Z]/.test(word) && word.length <= 6) return word;

      const hyParts = word.split("-");
      const rebuilt = hyParts.map((w, hIdx) => {
        const cleaned = w.replace(/[^\p{L}\p{N}'‚Äô]/gu, "");
        const lower = cleaned.toLowerCase();
        const isFirst = idx === 0 && hIdx === 0;
        const isLast = idx === parts.length - 1 && hIdx === hyParts.length - 1;
        if (!cleaned) return w;
        if (!isFirst && !isLast && lowerWords.has(lower)) return w.replace(cleaned, lower);
        const cap = lower.charAt(0).toUpperCase() + lower.slice(1);
        return w.replace(cleaned, cap);
      });
      return rebuilt.join("-");
    }).join("");
  }

  function isBlockedShow(artist){
    return /^abf\s*club\b/i.test(String(artist || "").trim());
  }
  function blockedVoteMsg(){
    alert("Voting is disabled for ABF CLUB shows. Please vote for tracks only üôÇ");
  }

  function markSessionVoted(norm){
    window.__abfVotedSession = window.__abfVotedSession || {};
    window.__abfVotedSession[norm] = nowTs();
  }
  function sessionAlreadyVoted(norm){
    const m = window.__abfVotedSession || {};
    const last = m[norm] || 0;
    return (nowTs() - last) < DAY;
  }

  function loadHistory(){
    let raw = [];
    try{ raw = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]"); }
    catch{ raw = []; }
    return (raw || []).map((x) => {
      if (typeof x === "string") return { t: x, ts: 0, cover_url: "" };
      if (x && typeof x === "object" && typeof x.t === "string") {
        return { t: x.t, ts: Number(x.ts) || 0, cover_url: String(x.cover_url || "") };
      }
      return null;
    }).filter(Boolean);
  }

  async function fetchServerNowPlaying(limit = 80){
    try{
      const res = await fetch(`/api/nowplaying?limit=${limit}`, { cache: "no-store" });
      const data = await res.json().catch(()=> ({}));
      if (!data?.ok) return [];

      const out = [];

      if (data?.now){
        const rawNow = String(data?.now?.raw || "").trim();
        const a = String(data?.now?.artist || "").trim();
        const t = String(data?.now?.title || "").trim();
        const raw = rawNow || (a || t ? `${a} - ${t}`.trim() : "");
        if (raw){
          out.push({
            t: raw,
            ts: Number(data?.now?.played_at_ms) ||
                (data?.now?.played_at ? new Date(data.now.played_at).getTime() : Date.now()),
            cover_url: String(data?.now?.cover_url || ""),
            cover_source: String(data?.now?.cover_source || "")
          });
        }
      }

      if (Array.isArray(data?.history)){
        for (const row of data.history){
          const raw = String(row?.raw || `${row?.artist || ""} - ${row?.title || ""}`.trim() || "").trim();
          if (!raw) continue;
          out.push({
            t: raw,
            ts: Number(row?.played_at_ms) ||
                (row?.played_at ? new Date(row.played_at).getTime() : 0),
            cover_url: String(row?.cover_url || ""),
            cover_source: String(row?.cover_source || "")
          });
        }
      }

      const seen = new Set();
      const deduped = [];
      for (const item of out){
        const k = String(item.t || "").toLowerCase();
        if (!k || seen.has(k)) continue;
        seen.add(k);
        deduped.push(item);
      }

      return deduped.slice(0, limit);
    }catch{
      return [];
    }
  }

  function setCover(url, root){
    const img = root?.querySelector("#musicCover");
    if (!img) return;
    const u = String(url || "").trim();
    if (u){
      img.src = u;
      img.classList.remove("hidden");
    } else {
      img.removeAttribute("src");
      img.classList.add("hidden");
    }
  }

  // ‚úÖ Always show cover source when cover exists (even without cover_source)
  function inferCoverSource(coverUrl, explicitSource){
    const src = String(explicitSource || "").toLowerCase().trim();
    const u = String(coverUrl || "").toLowerCase().trim();

    if (src.includes("directus")) return "directus";
    if (src.includes("itunes") || src.includes("apple")) return "itunes";

    if (u.includes("mzstatic.com")) return "itunes";
    if (u.includes("/assets/") || u.includes("directus")) return "directus";

    return u ? "other" : "";
  }

  function setCoverSourceBadge(root, coverUrl, explicitSource){
    const el = root?.querySelector("#npCoverSource");
    if (!el) return;

    const kind = inferCoverSource(coverUrl, explicitSource);

    if (!kind){
      el.classList.add("hidden");
      el.textContent = "";
      return;
    }

    if (kind === "directus"){
      el.className = "inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-semibold border tabular-nums bg-purple-500/15 border-purple-400/25 text-purple-200";
      el.textContent = "Directus cover";
      el.classList.remove("hidden");
      return;
    }

    if (kind === "itunes"){
      el.className = "inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-semibold border tabular-nums bg-cyan-500/10 border-cyan-400/20 text-cyan-200";
      el.textContent = "iTunes cover";
      el.classList.remove("hidden");
      return;
    }

    el.className = "inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-semibold border tabular-nums bg-white/5 border-white/10 text-white/70";
    el.textContent = "Cover";
    el.classList.remove("hidden");
  }

  function coverHtmlByUrl(url, sizeClass = "w-12 h-12 rounded-2xl"){
    const u = String(url || "").trim();
    return `
      <div class="abfCover ${sizeClass} border border-white/10 overflow-hidden flex-none bg-black/20">
        <img src="${u ? esc(u) : ""}" alt="" class="${u ? "w-full h-full object-cover" : "hidden"}" loading="lazy" decoding="async" />
        <div class="abfCoverFallback w-full h-full grid place-items-center">
          <img src="/logo-abf.png" alt="ABF" loading="lazy" decoding="async" class="w-8 h-8 opacity-90" />
        </div>
      </div>
    `;
  }

  function LAST_PLAYED_LIMIT(){ return 23; }

  const VOTES_TTL_MS = 10_000;
  function votesCacheKey(week){ return `votes:${week}`; }

  async function apiGetTopWeek(week){
    const k = votesCacheKey(week);
    window.__abfVotesCache = window.__abfVotesCache || {};
    const c = window.__abfVotesCache[k];
    const now = nowTs();
    if (c && now < c.exp) return c.payload || { top: [] };

    try{
      const res = await fetch(`/api/vote?week=${encodeURIComponent(week)}`, { cache: "no-store" });
      const data = await res.json().catch(() => ({}));
      const top = Array.isArray(data?.top) ? data.top : [];
      const payload = { top };
      window.__abfVotesCache[k] = { exp: now + VOTES_TTL_MS, payload };
      return payload;
    }catch{
      return { top: [] };
    }
  }

  async function apiVote(trackKeyRaw, artist = "", title = ""){
    const week = getISOWeekId();
    const res = await fetch("/api/vote", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ week, track_key: trackKeyRaw, artist, title }),
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok || data?.ok === false){
      return { ok: false, status: res.status, error: data?.error || `HTTP ${res.status}`, reason: data?.reason || "" };
    }
    return { ok: true, status: res.status, week: data?.week || week, count: data?.count };
  }

  function voteErrorToast(r){
    if (r?.status === 429){
      alert("You already voted today. Come back in 24h üôÇ");
      return;
    }
    if (r?.status === 409 || r?.reason === "cooldown"){
      alert("You already voted for this track. Come back in 24h üôÇ");
      return;
    }
    alert(`Vote failed: ${r?.error || "Unknown error"}`);
  }

  function buildVoteIndex(topRows){
    const exact = Object.create(null);
    const lower = Object.create(null);
    const byNorm = Object.create(null);

    for (const row of (topRows || [])){
      const tk = String(row?.track_key || "").trim();
      const c = Number(row?.count || 0);
      if (!tk) continue;

      exact[tk] = c;
      lower[tk.toLowerCase()] = c;

      const sp = splitTrack(tk);
      const n = normKey(sp.artist, sp.title);
      if (n) byNorm[n] = c;
    }

    return {
      getCount(trackKeyRaw, artistMaybe, titleMaybe){
        const k = String(trackKeyRaw || "").trim();
        if (k && exact[k] != null) return exact[k];
        if (k && lower[k.toLowerCase()] != null) return lower[k.toLowerCase()];

        const sp = k ? splitTrack(k) : { artist: String(artistMaybe||""), title: String(titleMaybe||"") };
        const n = normKey(sp.artist, sp.title);
        if (n && byNorm[n] != null) return byNorm[n];

        return 0;
      }
    };
  }

  // ---- Search by day/time ----
  function toLocalKey(ts){
    const d = new Date(ts);
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    const hh = String(d.getHours()).padStart(2,"0");
    const mi = String(d.getMinutes()).padStart(2,"0");
    return { date: `${yyyy}-${mm}-${dd}`, time: `${hh}:${mi}` };
  }

  function findClosestByDateTime(history, dateStr, timeStr, toleranceMinutes = 12){
    if (!dateStr || !timeStr) return null;
    const [y,m,d] = dateStr.split("-").map(Number);
    const [hh,mi] = timeStr.split(":").map(Number);
    if (!y || !m || !d || Number.isNaN(hh) || Number.isNaN(mi)) return null;

    const target = new Date(y, (m - 1), d, hh, mi, 0, 0).getTime();
    const tol = toleranceMinutes * 60 * 1000;

    let best = null;
    let bestDelta = Infinity;

    for (const entry of (history || [])){
      const ts = Number(entry?.ts || 0);
      if (!ts) continue;

      const k = toLocalKey(ts);
      if (k.date !== dateStr) continue;

      const delta = Math.abs(ts - target);
      if (delta < bestDelta){
        bestDelta = delta;
        best = entry;
      }
    }

    if (!best) return null;
    return { best, bestDelta, within: bestDelta <= tol };
  }

  function renderAirSearchResult(root, payload){
    const box = root.querySelector("#airSearchResult");
    if (!box) return;

    if (!payload){
      box.classList.add("hidden");
      box.innerHTML = "";
      return;
    }

    const { best, bestDelta, within } = payload;
    const t = splitTrack(best.t);
    const time = fmtTime(best.ts);
    const d = toLocalKey(best.ts).date;

    const artist = upperArtist(String(t.artist || "‚Äî"));
    const title = titleCaseEN(stripTitleSuffixes(String(t.title || "‚Äî")));

    box.classList.remove("hidden");
    box.innerHTML = `
      <div class="rounded-2xl border border-white/10 bg-white/[0.04] p-3">
        <div class="flex items-center justify-between gap-3">
          <div class="text-xs text-white/60">
            ${within ? "Closest match found" : "Closest match (outside tolerance)"} ‚Ä¢
            <span class="tabular-nums">${esc(d)} ${esc(time)}</span>
          </div>
          <div class="text-xs text-white/45 tabular-nums">Œî ${Math.round(bestDelta/60000)}m</div>
        </div>
        <div class="mt-2 font-extrabold text-white truncate">${esc(artist)}</div>
        <div class="text-white/65 text-sm truncate">${esc(title)}</div>
      </div>
    `;
  }

  function bindAirSearchOnce(root){
    if (!root || state.searchBound) return;

    const dateEl = root.querySelector("#airDate");
    const timeEl = root.querySelector("#airTime");
    const btnEl  = root.querySelector("#airSearchBtn");
    if (!dateEl || !timeEl || !btnEl) return;

    if (!dateEl.value){
      const n = new Date();
      const yyyy = n.getFullYear();
      const mm = String(n.getMonth() + 1).padStart(2,"0");
      const dd = String(n.getDate()).padStart(2,"0");
      dateEl.value = `${yyyy}-${mm}-${dd}`;
    }
    if (!timeEl.value){
      const n = new Date();
      timeEl.value = `${String(n.getHours()).padStart(2,"0")}:${String(n.getMinutes()).padStart(2,"0")}`;
    }

    const run = () => {
      state.search.date = dateEl.value || "";
      state.search.time = timeEl.value || "";
      const payload = findClosestByDateTime(state.lastHistory, state.search.date, state.search.time, 12);
      renderAirSearchResult(root, payload);
    };

    btnEl.addEventListener("click", run);
    dateEl.addEventListener("change", run);
    timeEl.addEventListener("change", run);

    state.searchBound = true;
    run();
  }

  function badgeTimeBlue(text){
    return `
      <span class="inline-flex items-center gap-2 px-2.5 py-1 rounded-full bg-cyan-500/10 border border-cyan-400/20 text-cyan-200 text-[11px] font-semibold tabular-nums">
        <span class="w-2 h-2 rounded-full bg-cyan-300/80"></span>
        ${esc(text || "--:--")}
      </span>
    `;
  }

  function rowHtml({ coverUrl, artist, title, time, count, blocked, voted, kNorm, kRaw, aRaw, tRaw }){
    return `
      <div class="abfHistoryRow ${voted ? "abfVotedRow" : ""} flex items-center justify-between gap-3 border border-white/10 bg-white/[0.03] hover:bg-white/[0.05] transition rounded-2xl p-3">
        <div class="flex items-center gap-3 min-w-0 flex-1">
          ${coverHtmlByUrl(coverUrl)}
          <div class="min-w-0 flex-1">
            <div class="flex items-center justify-between gap-3">
              <div class="font-extrabold text-white truncate">${esc(artist || "‚Äî")}</div>
              ${badgeTimeBlue(time)}
            </div>
            <div class="text-white/65 text-sm truncate">${esc(title || "‚Äî")}</div>
          </div>
        </div>

        <button
          class="voteBtn flex-none bg-white/5 hover:bg-white/10 border border-white/10 rounded-2xl px-3 py-2 text-sm text-white/85 transition"
          data-norm="${esc(kNorm)}"
          data-raw="${esc(kRaw)}"
          data-artist="${esc(aRaw || "")}"
          data-title="${esc(tRaw || "")}"
          data-blocked="${blocked ? "1" : "0"}"
          data-voted="${voted ? "1" : "0"}"
          type="button"
          aria-label="Vote"
          title="${blocked ? "Voting disabled for ABF CLUB" : (voted ? "Already voted today" : "Vote")}"
          style="${(blocked || voted) ? "opacity:0.55;cursor:not-allowed;" : ""}"
        >
          üëç <span class="voteCount tabular-nums">${esc(String(count ?? 0))}</span>
        </button>
      </div>
    `;
  }

  function rankBadgeClass(rank){
    if (rank === 1) return "bg-amber-400/15 border-amber-300/30 text-amber-200";
    if (rank === 2) return "bg-slate-200/10 border-slate-200/25 text-slate-100";
    if (rank === 3) return "bg-orange-400/15 border-orange-300/30 text-orange-200";
    return "bg-cyan-500/10 border-cyan-400/20 text-cyan-100";
  }

  function chartRowHtml(rank, coverUrl, artist, title, count, max){
    const pct = Math.round((Number(count) / Math.max(1, Number(max))) * 100);
    return `
      <li class="group flex items-center gap-4 p-4 rounded-3xl border border-white/10 bg-white/[0.03] hover:bg-white/[0.05] transition">
        <div class="flex-none w-10 h-10 rounded-2xl border ${rankBadgeClass(rank)} flex items-center justify-center text-sm font-extrabold tabular-nums">
          ${rank}
        </div>
        ${coverHtmlByUrl(coverUrl)}
        <div class="min-w-0 flex-1">
          <div class="flex items-start gap-3">
            <div class="min-w-0">
              <div class="font-extrabold text-white truncate">${esc(artist)}</div>
              <div class="text-white/65 text-sm truncate">${esc(title)}</div>
            </div>
            <div class="ml-auto flex-none text-sm text-white/90 font-extrabold tabular-nums">
              ${esc(String(count))} <span class="text-white/50 font-normal">votes</span>
            </div>
          </div>
          <div class="mt-3 h-2 rounded-full bg-white/5 border border-white/10 overflow-hidden">
            <div class="h-full bg-gradient-to-r from-[#145C8F] to-[#2FC2FF]" style="width:${pct}%"></div>
          </div>
        </div>
      </li>
    `;
  }

  async function render(){
    if (!isMusicRoute()) return;
    const root = getRoot();
    if (!root) return;

    if (state.inFlight) return;
    state.inFlight = true;

    try{
      const artistEl = root.querySelector("#musicArtist");
      const titleEl  = root.querySelector("#musicTitle");
      const timeEl   = root.querySelector("#musicTime");

      const histEl   = root.querySelector("#historyTable");
      const histEmpty= root.querySelector("#historyEmpty");

      const nowVoteBtn   = root.querySelector("#nowVoteBtn");
      const nowVoteCount = root.querySelector("#nowVoteCount");

      const weekThisEl = root.querySelector("#weekThis");
      const weekPrevEl = root.querySelector("#weekPrev");
      const howWeekThis = root.querySelector("#howWeekThis");
      const howWeekPrev = root.querySelector("#howWeekPrev");

      const topThisEl = root.querySelector("#topThisWeek");
      const topPrevEl = root.querySelector("#topPrevWeek");
      const topThisEmpty = root.querySelector("#topThisEmpty");
      const topPrevEmpty = root.querySelector("#topPrevEmpty");

      const week = getISOWeekId();
      const prevWeek = getPrevISOWeekId();

      if (weekThisEl) weekThisEl.textContent = week.replace("-W"," W");
      if (weekPrevEl) weekPrevEl.textContent = prevWeek.replace("-W"," W");
      if (howWeekThis) howWeekThis.textContent = week.replace("-W"," W");
      if (howWeekPrev) howWeekPrev.textContent = prevWeek.replace("-W"," W");

      if (!artistEl || !titleEl || !histEl || !topThisEl || !topPrevEl) return;

      let history = await fetchServerNowPlaying(80);
      if (!history.length) history = loadHistory();
      state.lastHistory = history || [];

      if (!history.length){
        artistEl.textContent = "‚Äî";
        titleEl.textContent = "‚Äî";
        if (timeEl) timeEl.textContent = "--:--";
        setCover("", root);
        setCoverSourceBadge(root, "", "");

        if (histEmpty) histEmpty.classList.remove("hidden");
        histEl.innerHTML = "";

        if (nowVoteBtn) nowVoteBtn.style.display = "none";

        if (topThisEmpty) topThisEmpty.classList.remove("hidden");
        if (topPrevEmpty) topPrevEmpty.classList.remove("hidden");
        topThisEl.innerHTML = "";
        topPrevEl.innerHTML = "";
        return;
      }

      if (histEmpty) histEmpty.classList.add("hidden");

      const coverByNorm = {};
      for (const entry of history){
        const t = splitTrack(entry.t);
        const n = normKey(t.artist, t.title);
        const u = String(entry.cover_url || "").trim();
        if (n && u) coverByNorm[n] = u;
      }

      const currentEntry = history[0];
      const current = splitTrack(currentEntry.t);

      const nowArtistRaw = String(current.artist || "").trim();
      const nowTitleRaw0 = String(current.title || "").trim();
      const nowTitleClean = stripTitleSuffixes(nowTitleRaw0);

      artistEl.textContent = upperArtist(nowArtistRaw || "‚Äî");
      titleEl.textContent  = titleCaseEN(nowTitleClean || "‚Äî");

      const nowTime = fmtTime(currentEntry.ts);
      if (timeEl) timeEl.textContent = nowTime;

      const nowCover =
        String(currentEntry.cover_url || "").trim() ||
        (coverByNorm[normKey(nowArtistRaw, nowTitleRaw0)] || "");
      setCover(nowCover, root);

      // ‚úÖ ensure source badge shows
      setCoverSourceBadge(root, nowCover, String(currentEntry.cover_source || ""));

      const [{ top: topThis }, { top: topPrev }] = await Promise.all([
        apiGetTopWeek(week),
        apiGetTopWeek(prevWeek),
      ]);

      const voteIndex = buildVoteIndex(topThis || []);

      // NOW vote
      const nowKNorm = normKey(nowArtistRaw, nowTitleRaw0);
      const nowKRaw  = rawKey(nowArtistRaw, nowTitleRaw0);
      const nowCount = voteIndex.getCount(nowKRaw, nowArtistRaw, nowTitleRaw0);
      const nowBlocked = isBlockedShow(nowArtistRaw);
      const nowAlready = sessionAlreadyVoted(nowKNorm);

      if (nowVoteCount) nowVoteCount.textContent = String(nowCount);

      if (nowVoteBtn){
        nowVoteBtn.style.display = "inline-flex";

        // ‚úÖ grey when already voted OR blocked + add class for stronger disabled look
        if (nowBlocked || nowAlready){
          nowVoteBtn.classList.add("is-voted");
          nowVoteBtn.style.opacity = "0.55";
          nowVoteBtn.style.cursor  = "not-allowed";
        } else {
          nowVoteBtn.classList.remove("is-voted");
          nowVoteBtn.style.opacity = "1";
          nowVoteBtn.style.cursor  = "pointer";
        }

        nowVoteBtn.dataset.raw = nowKRaw;
        nowVoteBtn.dataset.norm = nowKNorm;
        nowVoteBtn.dataset.artist = nowArtistRaw;
        nowVoteBtn.dataset.title = nowTitleRaw0;
        nowVoteBtn.dataset.blocked = nowBlocked ? "1" : "0";

        if (!nowVoteBtn.dataset.listenerAttached){
          nowVoteBtn.dataset.listenerAttached = "true";
          nowVoteBtn.addEventListener("click", async () => {
            const root = getRoot();
            if (!root) return;

            const btn = root.querySelector("#nowVoteBtn");
            if (!btn) return;

            const blocked = btn.dataset.blocked === "1";
            const kNorm = btn.dataset.norm || "";
            const kRaw = btn.dataset.raw || "";
            const a = btn.dataset.artist || "";
            const t = btn.dataset.title || "";

            if (blocked){
              blockedVoteMsg();
              return;
            }
            if (sessionAlreadyVoted(kNorm)){
              alert("You already voted for this track. Come back in 24h üôÇ");
              btn.classList.add("is-voted");
              btn.style.opacity = "0.55";
              btn.style.cursor = "not-allowed";
              return;
            }

            btn.style.opacity = "0.7";
            btn.style.cursor = "wait";

            const r = await apiVote(kRaw, a, t);
            if (!r.ok){
              btn.style.opacity = "1";
              btn.style.cursor = "pointer";
              voteErrorToast(r);
              return;
            }

            markSessionVoted(kNorm);

            const ck = votesCacheKey(getISOWeekId());
            if (window.__abfVotesCache?.[ck]) window.__abfVotesCache[ck].exp = 0;

            // ‚úÖ grey after success
            btn.classList.add("is-voted");
            btn.style.opacity = "0.55";
            btn.style.cursor = "not-allowed";

            render();
          });
        }
      }

      // LAST PLAYED (23)
      const limit = LAST_PLAYED_LIMIT();
      const rows = history.slice(1, 1 + limit);

      histEl.innerHTML = rows.map((entry) => {
        const t = splitTrack(entry.t);
        const aRaw = String(t.artist || "").trim();
        const tRaw0 = String(t.title || "").trim();
        const tClean = stripTitleSuffixes(tRaw0);

        const kNorm = normKey(aRaw, tRaw0);
        const kRaw  = rawKey(aRaw, tRaw0);

        const coverUrl =
          String(entry.cover_url || "").trim() ||
          (coverByNorm[normKey(aRaw, tRaw0)] || "");

        const count = voteIndex.getCount(kRaw, aRaw, tRaw0);
        const blocked = isBlockedShow(aRaw);
        const voted = sessionAlreadyVoted(kNorm);

        return rowHtml({
          coverUrl,
          artist: upperArtist(aRaw || "‚Äî"),
          title: titleCaseEN(tClean || "‚Äî"),
          time: fmtTime(entry.ts),
          count,
          blocked,
          voted,
          kNorm,
          kRaw,
          aRaw,
          tRaw: tRaw0
        });
      }).join("");

      // wire vote buttons (‚úÖ grey after vote + row grey)
      histEl.querySelectorAll(".voteBtn").forEach((btn) => {
        const kNorm = btn.dataset.norm || "";
        const kRaw  = btn.dataset.raw || "";
        const a     = btn.dataset.artist || "";
        const t0    = btn.dataset.title || "";
        const blocked = btn.dataset.blocked === "1";
        const countEl = btn.querySelector(".voteCount");

        const c = voteIndex.getCount(kRaw, a, t0);
        if (countEl) countEl.textContent = String(c);

        const row = btn.closest(".abfHistoryRow");
        const already = sessionAlreadyVoted(kNorm);

        if (blocked){
          btn.style.opacity = "0.45";
          btn.style.cursor  = "not-allowed";
          if (row) row.classList.add("abfVotedRow");
          btn.onclick = () => blockedVoteMsg();
          return;
        }

        if (already){
          btn.style.opacity = "0.55";
          btn.style.cursor  = "not-allowed";
          if (row) row.classList.add("abfVotedRow");
          btn.onclick = () => {
            alert("You already voted for this track. Come back in 24h üôÇ");
          };
          return;
        } else {
          if (row) row.classList.remove("abfVotedRow");
          btn.style.opacity = "1";
          btn.style.cursor  = "pointer";
        }

        btn.onclick = async () => {
          if (sessionAlreadyVoted(kNorm)){
            alert("You already voted for this track. Come back in 24h üôÇ");
            btn.style.opacity = "0.55";
            btn.style.cursor  = "not-allowed";
            if (row) row.classList.add("abfVotedRow");
            return;
          }

          btn.style.opacity = "0.7";
          btn.style.cursor = "wait";

          const r = await apiVote(kRaw || rawKey(a, t0), a, t0);
          if (!r.ok){
            btn.style.opacity = "1";
            btn.style.cursor = "pointer";
            voteErrorToast(r);
            return;
          }

          markSessionVoted(kNorm);

          const ck = votesCacheKey(week);
          if (window.__abfVotesCache?.[ck]) window.__abfVotesCache[ck].exp = 0;

          // ‚úÖ grey after success (button + row)
          btn.style.opacity = "0.55";
          btn.style.cursor = "not-allowed";
          if (row) row.classList.add("abfVotedRow");

          render();
        };
      });

      // TOP THIS WEEK
      const topThisSafe = (topThis || [])
        .filter(x => x && x.track_key && !isBlockedShow(String(x.artist || "")))
        .slice(0, 10);

      if (!topThisSafe.length){
        if (topThisEmpty) topThisEmpty.classList.remove("hidden");
        topThisEl.innerHTML = "";
      } else {
        if (topThisEmpty) topThisEmpty.classList.add("hidden");
        const max = Math.max(...topThisSafe.map(x => Number(x.count || 0)), 1);

        topThisEl.innerHTML = topThisSafe.map((row, idx) => {
          const tk = String(row.track_key || "");
          const sp = splitTrack(tk);

          const aRaw = String(row.artist || "").trim() || sp.artist || "‚Äî";
          const tRaw = String(row.title || "").trim() || sp.title || "‚Äî";

          const coverUrl =
            String(row.cover_url || "").trim() ||
            (coverByNorm[normKey(sp.artist, sp.title)] || "");

          return chartRowHtml(
            idx + 1,
            coverUrl,
            upperArtist(aRaw),
            titleCaseEN(stripTitleSuffixes(tRaw)),
            Number(row.count || 0),
            max
          );
        }).join("");
      }

      // TOP PREV WEEK
      const topPrevSafe = (topPrev || [])
        .filter(x => x && x.track_key && !isBlockedShow(String(x.artist || "")))
        .slice(0, 5);

      if (!topPrevSafe.length){
        if (topPrevEmpty) topPrevEmpty.classList.remove("hidden");
        topPrevEl.innerHTML = "";
      } else {
        if (topPrevEmpty) topPrevEmpty.classList.add("hidden");
        const maxP = Math.max(...topPrevSafe.map(x => Number(x.count || 0)), 1);

        topPrevEl.innerHTML = topPrevSafe.map((row, idx) => {
          const tk = String(row.track_key || "");
          const sp = splitTrack(tk);

          const aRaw = String(row.artist || "").trim() || sp.artist || "‚Äî";
          const tRaw = String(row.title || "").trim() || sp.title || "‚Äî";

          const coverUrl =
            String(row.cover_url || "").trim() ||
            (coverByNorm[normKey(sp.artist, sp.title)] || "");

          return chartRowHtml(
            idx + 1,
            coverUrl,
            upperArtist(aRaw),
            titleCaseEN(stripTitleSuffixes(tRaw)),
            Number(row.count || 0),
            maxP
          );
        }).join("");
      }

      // search refresh
      if (state.search?.date && state.search?.time){
        const payload = findClosestByDateTime(state.lastHistory, state.search.date, state.search.time, 12);
        renderAirSearchResult(root, payload);
      }

      state.lastRenderAt = nowTs();
    } finally {
      state.inFlight = false;
    }
  }

  function stopTimer(){
    if (state.timer) clearInterval(state.timer);
    state.timer = null;
  }

  function startTimer(){
    stopTimer();
    state.timer = setInterval(() => {
      if (state.inFlight) return;
      render();
    }, 8000);
  }

  function init(){
    if (!isMusicRoute()) return;
    const root = getRoot();
    if (!root) return;

    bindAirSearchOnce(root);
    render();
    startTimer();
  }

  if (!state.bound){
    state.bound = true;

    document.addEventListener("astro:page-load", init);
    document.addEventListener("astro:after-swap", init);

    document.addEventListener("astro:before-swap", () => {
      stopTimer();
    });

    window.addEventListener("abf:history-updated", () => {
      if (!isMusicRoute()) return;
      render();
    });

    window.addEventListener("resize", () => {
      if (!isMusicRoute()) return;
      const t = nowTs();
      if (t - state.lastRenderAt > 400) render();
    });
  }

  init();
})();
    </script>
  </div>
</Base>