---
import Base from "../layouts/Base.astro";
export const prerender = false;
---
<Base
  title="Music ‚Äî RadioABF"
  description="Live history, covers and weekly community votes on RadioABF."
  canonical="/music"
  image="/og-image.jpg"
>
  <!-- ROOT WRAPPER -->
  <div id="musicPageRoot">
    <!-- HERO -->
    <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-[#0A1F33] p-5 sm:p-6 mb-6 shadow-2xl">
      <div class="pointer-events-none absolute -top-40 -left-40 w-[520px] h-[520px] rounded-full bg-cyan-500/15 blur-[120px]"></div>
      <div class="pointer-events-none absolute -bottom-40 -right-40 w-[520px] h-[520px] rounded-full bg-blue-600/15 blur-[120px]"></div>
      <div class="relative z-10">
        <div class="flex items-start justify-between gap-4 flex-wrap">
          <div class="min-w-0">
            <div class="flex items-center gap-3 text-sm tracking-widest text-white/60 uppercase mb-3">
              <span class="w-2 h-2 bg-cyan-400 rounded-full animate-pulse"></span>
              Music
            </div>
            <h1 class="text-3xl sm:text-4xl font-extrabold leading-tight">
              Community Music & Charts <span class="text-cyan-200">on RadioABF</span>
            </h1>
            <p class="text-white/65 mt-3 max-w-2xl">
              Live history, covers and weekly community votes.
            </p>
          </div>

          <!-- Badges -->
          <div class="flex items-center justify-start lg:justify-end gap-2 flex-nowrap overflow-x-auto no-scrollbar">
            <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-2 rounded-xl flex-none">
              Vote: 1 / track / day
            </span>
            <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-2 rounded-xl flex-none">
              Covers: Directus ‚Üí iTunes
            </span>
            <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-2 rounded-xl flex-none">
              Updates every 8s
            </span>
          </div>
        </div>
      </div>
    </section>

    <!-- PORTAL GRID -->
    <section class="mt-6 grid grid-cols-1 xl:grid-cols-[minmax(0,1fr)_minmax(0,0.85fr)] gap-6 items-start">
      <!-- LEFT COLUMN -->
      <div class="space-y-6">
        <!-- Now Playing + History Card -->
        <div class="rounded-3xl border border-white/10 bg-[#0A1F33] overflow-hidden shadow-xl">
          <div class="p-5 md:p-6 border-b border-white/10">
            <div class="flex items-center justify-between gap-4 flex-wrap">
              <div class="min-w-0">
                <div class="text-sm text-white/60 uppercase tracking-wider">Now playing</div>
                <div class="text-xs text-white/50 mt-1">Live metadata ‚Ä¢ clean titles ‚Ä¢ voting enabled</div>
              </div>
              <div class="flex items-center gap-2">
                <div id="npLiveBadge" class="inline-flex items-center gap-2 px-3 py-1.5 rounded-full bg-red-500/15 border border-red-500/25 text-red-200 text-xs font-semibold tracking-wider">
                  <span class="w-2 h-2 rounded-full bg-red-400 animate-pulse"></span>
                  LIVE
                </div>
                <div id="npCoverSource" class="hidden inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-semibold border tabular-nums" aria-label="Cover source">
                  ‚Äî
                </div>
                <div id="npTimeBadge" class="inline-flex items-center gap-2 px-3 py-1.5 rounded-full bg-cyan-500/10 border border-cyan-400/20 text-cyan-200 text-xs font-semibold tabular-nums" aria-label="Now playing time">
                  <span class="w-2 h-2 rounded-full bg-cyan-300/80"></span>
                  <span id="musicTime">--:--</span>
                </div>
              </div>
            </div>
            <div class="mt-5 rounded-3xl border border-white/10 bg-white/5 overflow-hidden">
              <div class="p-4 md:p-5 flex flex-col sm:flex-row gap-5 items-center sm:items-stretch">
                <div class="flex-none">
                  <div id="musicCoverWrapper" class="abfCover w-24 h-24 md:w-28 md:h-28 rounded-2xl border border-white/10 overflow-hidden shadow-xl bg-black/20">
                    <img id="musicCover" class="hidden w-full h-full object-cover" alt="Current cover" />
                    <div class="abfCoverFallback w-full h-full grid place-items-center">
                      <img src="/logo-abf.png" alt="ABF" loading="lazy" decoding="async" class="w-16 h-16 opacity-90" />
                    </div>
                  </div>
                </div>
                <div class="min-w-0 flex-1">
                  <div id="musicArtist" class="text-xl md:text-2xl font-extrabold text-white truncate leading-tight">‚Äî</div>
                  <div id="musicTitle" class="mt-1 text-white/70 text-base md:text-lg truncate">‚Äî</div>
                  <div class="mt-4 flex flex-wrap items-center gap-2">
                    <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-1.5 rounded-xl">
                      1 vote / track / day
                    </span>
                    <span class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-1.5 rounded-xl">
                      ABF CLUB not votable
                    </span>
                  </div>
                </div>
                <button
                  id="nowVoteBtn"
                  class="voteBtnMini flex-none bg-white/5 hover:bg-white/10 border border-white/10 rounded-2xl px-4 py-3 text-sm text-white/85 transition inline-flex items-center gap-2"
                  type="button"
                  aria-label="Vote for now playing"
                >
                  üëç <span class="tabular-nums font-semibold" id="nowVoteCount">0</span>
                </button>
              </div>
            </div>
          </div>
          <!-- HISTORY TABLE -->
          <div class="p-4 md:p-6">
            <div class="flex items-center justify-between gap-4 mb-4">
              <div class="text-sm text-white/60 uppercase tracking-wider">Last played</div>
              <div class="text-xs text-white/50">Tap üëç to vote</div>
            </div>
            <div
              id="historyTable"
              class="space-y-3 max-h-[70vh] xl:max-h-none overflow-y-auto scrollbar-thin scrollbar-thumb-white/20 scrollbar-track-transparent pr-1"
            ></div>
            <div id="historyEmpty" class="text-white/55 text-sm hidden">
              Start the player to load history.
            </div>
          </div>
        </div>

        <!-- CARD RECHERCHE -->
        <div class="rounded-3xl border border-white/10 bg-[#0A1F33] overflow-hidden shadow-xl">
          <div class="p-5 border-b border-white/10">
            <div class="text-sm text-white/60 uppercase tracking-wider">Search airplay time</div>
            <div class="text-xs text-white/50 mt-1">Find closest track by date and time</div>
          </div>
          <div class="p-5">
            <div class="grid grid-cols-1 sm:grid-cols-[1fr_120px_auto] gap-3">
              <input id="airDate" type="date" class="abfInput" aria-label="Air date" placeholder="Select date" />
              <input id="airTime" type="time" class="abfInput" aria-label="Air time" placeholder="Select time" />
              <button id="airSearchBtn" type="button" class="abfBtn">Search</button>
            </div>
            <div id="airSearchResult" class="mt-4"></div>
          </div>
        </div>
      </div>

      <!-- RIGHT COLUMN -->
      <aside class="space-y-6">
        <!-- THIS WEEK -->
        <div class="rounded-3xl border border-white/10 bg-[#0A1F33] overflow-hidden shadow-xl">
          <div class="p-5 border-b border-white/10 flex items-start justify-between gap-4">
            <div class="min-w-0">
              <div class="text-sm text-white/60 uppercase tracking-wider">Top this week</div>
              <div class="text-xs text-white/50 mt-1">Community votes ‚Ä¢ real-time updates</div>
            </div>
            <div class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-1.5 rounded-xl flex-none">
              Week <span id="weekThis" class="tabular-nums">‚Äî</span>
            </div>
          </div>
          <div class="p-4 md:p-5">
            <ol id="topThisWeek" class="space-y-3"></ol>
            <div id="topThisEmpty" class="text-white/55 text-sm hidden">
              No votes yet ‚Äî be the first üôÇ
            </div>
          </div>
        </div>

        <!-- PREVIOUS WEEK -->
        <div class="rounded-3xl border border-white/10 bg-[#0A1F33] overflow-hidden shadow-xl">
          <div class="p-5 border-b border-white/10 flex items-start justify-between gap-4">
            <div class="min-w-0">
              <div class="text-sm text-white/60 uppercase tracking-wider">Last week</div>
              <div class="text-xs text-white/50 mt-1">Top 5 snapshot</div>
            </div>
            <div class="text-xs text-white/70 border border-white/10 bg-white/5 px-3 py-1.5 rounded-xl flex-none">
              Week <span id="weekPrev" class="tabular-nums">‚Äî</span>
            </div>
          </div>
          <div class="p-4 md:p-5">
            <ol id="topPrevWeek" class="space-y-3"></ol>
            <div id="topPrevEmpty" class="text-white/55 text-sm hidden">
              No data for last week yet.
            </div>
          </div>
        </div>

        <!-- HOW IT WORKS ‚Äì TEXTE QUE TU VIENS DE ME DONNER -->
        <div class="rounded-3xl border border-white/10 bg-gradient-to-br from-[#061220] via-[#0A1F33] to-[#050B14] overflow-hidden shadow-xl relative">
          <div class="pointer-events-none absolute -top-24 -right-24 w-[260px] h-[260px] bg-cyan-500/15 rounded-full blur-[90px]"></div>
          <div class="p-6 relative">
            <div class="text-xs text-white/50 uppercase tracking-wider">How it works</div>
            <div class="mt-2 font-extrabold text-lg leading-tight">Community voting + covers system</div>
            <ul class="mt-3 text-sm text-white/70 leading-relaxed space-y-2 list-disc pl-5">
              <li><strong>1 vote per track per day.</strong><br>Every listener helps shape the weekly ABF chart.</li>
              <li><strong>ABF CLUB shows are not votable.</strong><br>Only individual tracks count toward the charts.</li>
              <li><strong>Covers system:</strong><br>Priorit√© aux pochettes manuelles upload√©es dans Directus,<br>sinon fallback automatique iTunes.</li>
              <li><strong>Weekly rankings reset every Monday (ISO week).</strong><br>Fresh chart, fresh competition.</li>
            </ul>
            <p class="mt-4 text-sm text-white/80 italic">
              ‚ÄúYour votes power the ABF weekly chart ‚Äî live, transparent, community-driven.‚Äù
            </p>
          </div>
        </div>
      </aside>
    </section>

    <style>
      .tabular-nums { font-variant-numeric: tabular-nums; }
      .scrollbar-thin::-webkit-scrollbar { width: 6px; }
      .scrollbar-thin::-webkit-scrollbar-track { background: transparent; }
      .scrollbar-thin::-webkit-scrollbar-thumb {
        background-color: rgba(255,255,255,0.2);
        border-radius: 9999px;
      }
      .abfInput {
        appearance: none;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.06);
        color: rgba(255,255,255,0.9);
        border-radius: 14px;
        padding: 10px 12px;
        font-size: 12px;
        outline: none;
      }
      .abfInput:focus {
        border-color: rgba(47,194,255,0.35);
        box-shadow: 0 0 0 3px rgba(47,194,255,0.10);
      }
      .abfBtn {
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.06);
        color: rgba(255,255,255,0.9);
        border-radius: 14px;
        padding: 10px 14px;
        font-size: 12px;
        font-weight: 800;
        transition: 150ms ease;
      }
      .abfBtn:hover { background: rgba(255,255,255,0.10); }
      .voteBtnMini { white-space: nowrap; }
      .abfVotedRow {
        opacity: 0.72;
        filter: saturate(0.65) brightness(0.92);
      }
      .abfVotedRow .voteBtn,
      .voteBtnMini.is-voted {
        opacity: 0.55 !important;
        cursor: not-allowed !important;
        background: rgba(255,255,255,0.03) !important;
      }
      #npCoverSource.directus {
        background: rgba(168,85,247,0.12);
        border-color: rgba(168,85,247,0.3);
        color: rgba(216,180,254,0.95);
      }
      #npCoverSource.itunes {
        background: rgba(236,72,153,0.12);
        border-color: rgba(236,72,153,0.3);
        color: rgba(249,168,212,0.95);
      }
      #npCoverSource.other {
        background: rgba(255,255,255,0.05);
        border-color: rgba(255,255,255,0.15);
        color: rgba(255,255,255,0.8);
      }
      .no-scrollbar::-webkit-scrollbar{ display:none; }
      .no-scrollbar{ -ms-overflow-style:none; scrollbar-width:none; }
    </style>

    <script is:inline data-astro-rerun>
(() => {
  const ROUTE = "/music";
  const KEY = "__abfMusicPortal";
  const DAY = 24 * 60 * 60 * 1000;
  const VOTED_KEY = "abf_voted_tracks";
  const HISTORY_KEY = "abf_history";
  const state = (window[KEY] = window[KEY] || {
    bound: false,
    timer: null,
    inFlight: false,
    lastRenderAt: 0,
    lastHistory: [],
    search: { date: "", time: "" },
    searchBound: false,
  });

  function loadVotedTracks() {
    try {
      const raw = localStorage.getItem(VOTED_KEY) || "{}";
      const voted = JSON.parse(raw);
      const now = nowTs();
      for (const k in voted) {
        if (now - voted[k] >= DAY) delete voted[k];
      }
      localStorage.setItem(VOTED_KEY, JSON.stringify(voted));
      return voted;
    } catch {
      return {};
    }
  }

  function markVoted(norm) {
    const voted = loadVotedTracks();
    voted[norm] = nowTs();
    localStorage.setItem(VOTED_KEY, JSON.stringify(voted));
  }

  function isVoted(norm) {
    const voted = loadVotedTracks();
    const last = voted[norm] || 0;
    return (nowTs() - last) < DAY;
  }

  function isMusicRoute() { return window.location.pathname === ROUTE; }
  function getRoot() { return document.getElementById("musicPageRoot"); }
  function nowTs() { return Date.now(); }

  function getISOWeekId(d = new Date()){
    const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
    const dayNum = date.getUTCDay() || 7;
    date.setUTCDate(date.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
    return `${date.getUTCFullYear()}-W${String(weekNo).padStart(2, "0")}`;
  }

  function getPrevISOWeekId(){
    const d = new Date();
    d.setDate(d.getDate() - 7);
    return getISOWeekId(d);
  }

  function esc(s){
    return String(s || "")
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }

  function fmtTime(ts){
    if (!ts) return "--:--";
    const d = new Date(ts);
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }

  function stripTitleSuffixes(input){
    let s = String(input || "").trim();
    if (!s) return "";
    const rx = /\s*[\(\[]\s*(?:(?:extended|original|radio|club|album|single|clean|explicit|short|long)\s*)?(?:mix|edit|version|remix|re\-mix|rework|bootleg|instrumental|acapella|a\s*cappella|dub|vip|remaster(?:ed)?|mono|stereo)\b[^)\]]*[\)\]]\s*/gi;
    s = s.replace(rx, " ");
    return s.replace(/\s{2,}/g, " ").trim();
  }

  function splitTrack(entry){
    const s = String(entry || "").trim().replace(/^undefined\s*-\s*/i, "");
    const idx = s.indexOf(" - ");
    if (idx === -1) return { artist: s.trim(), title: "" };
    return { artist: s.slice(0, idx).trim(), title: s.slice(idx + 3).trim() };
  }

  function normKey(artist, title){
    return (String(artist || "") + " - " + String(title || ""))
      .toLowerCase()
      .replace(/\u00A0/g, " ")
      .replace(/\s+/g, " ")
      .replace(/[‚Äú‚Äù"']/g, "")
      .trim();
  }

  function rawKey(artist, title){
    const a = String(artist || "").trim();
    const t = String(title || "").trim();
    return `${a} - ${t}`.trim();
  }

  function upperArtist(s){ return String(s || "‚Äî").trim().toUpperCase(); }

  function titleCaseEN(input){
    const s = String(input || "").trim();
    if (!s) return "‚Äî";
    const lowerWords = new Set([
      "a","an","the","and","but","or","nor","for","so","yet",
      "as","at","by","for","from","in","into","near","of","on","onto","over","per","to","up","via","with","within","without"
    ]);
    const parts = s.split(/(\s+)/);
    return parts.map((chunk, idx) => {
      if (/^\s+$/.test(chunk)) return chunk;
      const word = chunk;
      if (word === word.toUpperCase() && /[A-Z]/.test(word) && word.length <= 6) return word;
      const hyParts = word.split("-");
      const rebuilt = hyParts.map((w, hIdx) => {
        const cleaned = w.replace(/[^\p{L}\p{N}'‚Äô]/gu, "");
        const lower = cleaned.toLowerCase();
        const isFirst = idx === 0 && hIdx === 0;
        const isLast = idx === parts.length - 1 && hIdx === hyParts.length - 1;
        if (!cleaned) return w;
        if (!isFirst && !isLast && lowerWords.has(lower)) return w.replace(cleaned, lower);
        const cap = lower.charAt(0).toUpperCase() + lower.slice(1);
        return w.replace(cleaned, cap);
      });
      return rebuilt.join("-");
    }).join("");
  }

  function isBlockedShow(artist){
    return /^abf\s*club\b/i.test(String(artist || "").trim());
  }

  function blockedVoteMsg(){
    alert("Voting is disabled for ABF CLUB shows. Please vote for tracks only üôÇ");
  }

  function loadHistory(){
    let raw = [];
    try{ raw = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]"); }
    catch{ raw = []; }
    return (raw || []).map((x) => {
      if (typeof x === "string") return { t: x, ts: 0, cover_url: "" };
      if (x && typeof x === "object" && typeof x.t === "string") {
        return { t: x.t, ts: Number(x.ts) || 0, cover_url: String(x.cover_url || "") };
      }
      return null;
    }).filter(Boolean);
  }

  async function fetchServerNowPlaying(limit = 80){
    try{
      const res = await fetch(`/api/nowplaying?limit=${limit}`, { cache: "no-store" });
      const data = await res.json().catch(()=> ({}));
      if (!data?.ok) return [];
      const out = [];
      if (data?.now){
        const rawNow = String(data?.now?.raw || "").trim();
        const a = String(data?.now?.artist || "").trim();
        const t = String(data?.now?.title || "").trim();
        const raw = rawNow || (a || t ? `${a} - ${t}`.trim() : "");
        if (raw){
          out.push({
            t: raw,
            ts: Number(data?.now?.played_at_ms) ||
                (data?.now?.played_at ? new Date(data.now.played_at).getTime() : Date.now()),
            cover_url: String(data?.now?.cover_url || ""),
            cover_source: String(data?.now?.cover_source || "")
          });
        }
      }
      if (Array.isArray(data?.history)){
        for (const row of data.history){
          const raw = String(row?.raw || `${row?.artist || ""} - ${row?.title || ""}`.trim() || "").trim();
          if (!raw) continue;
          out.push({
            t: raw,
            ts: Number(row?.played_at_ms) ||
                (row?.played_at ? new Date(row.played_at).getTime() : 0),
            cover_url: String(row?.cover_url || ""),
            cover_source: String(row?.cover_source || "")
          });
        }
      }
      const seen = new Set();
      const deduped = [];
      for (const item of out){
        const k = String(item.t || "").toLowerCase();
        if (!k || seen.has(k)) continue;
        seen.add(k);
        deduped.push(item);
      }
      return deduped.slice(0, limit);
    }catch{
      return [];
    }
  }

  function setCover(url, root){
    const img = root?.querySelector("#musicCover");
    if (!img) return;
    const u = String(url || "").trim();
    if (u){
      img.src = u;
      img.classList.remove("hidden");
    } else {
      img.removeAttribute("src");
      img.classList.add("hidden");
    }
  }

  function inferCoverSource(coverUrl, explicitSource){
    const src = String(explicitSource || "").toLowerCase().trim();
    const u = String(coverUrl || "").toLowerCase().trim();
    if (src.includes("directus")) return "directus";
    if (src.includes("itunes") || src.includes("apple")) return "itunes";
    if (u.includes("mzstatic.com")) return "itunes";
    if (u.includes("/assets/") || u.includes("directus")) return "directus";
    return u ? "other" : "";
  }

  function setCoverSourceBadge(root, coverUrl, explicitSource){
    const el = root?.querySelector("#npCoverSource");
    if (!el) return;
    const kind = inferCoverSource(coverUrl, explicitSource);
    if (!kind){
      el.classList.add("hidden");
      el.textContent = "";
      return;
    }
    el.className = "inline-flex items-center gap-2 px-3 py-1.5 rounded-full text-xs font-semibold border tabular-nums";
    el.textContent = kind === "directus" ? "Directus cover" :
                     kind === "itunes"   ? "iTunes cover"   : "Cover";
    if (kind === "directus") el.classList.add("directus");
    if (kind === "itunes") el.classList.add("itunes");
    if (kind === "other") el.classList.add("other");
    el.classList.remove("hidden");
  }

  function coverHtmlByUrl(url, sizeClass = "w-12 h-12 rounded-2xl"){
    const u = String(url || "").trim();
    return `
      <div class="abfCover ${sizeClass} border border-white/10 overflow-hidden flex-none bg-black/20">
        <img src="${u ? esc(u) : ""}" alt="" class="${u ? "w-full h-full object-cover" : "hidden"}" loading="lazy" decoding="async" />
        <div class="abfCoverFallback w-full h-full grid place-items-center">
          <img src="/logo-abf.png" alt="ABF" loading="lazy" decoding="async" class="w-8 h-8 opacity-90" />
        </div>
      </div>
    `;
  }

  function LAST_PLAYED_LIMIT(){ return 19; }

  const VOTES_TTL_MS = 10_000;
  function votesCacheKey(week){ return `votes:${week}`; }

  async function apiGetTopWeek(week){
    const k = votesCacheKey(week);
    window.__abfVotesCache = window.__abfVotesCache || {};
    const c = window.__abfVotesCache[k];
    const now = nowTs();
    if (c && now < c.exp) return c.payload || { top: [] };
    try{
      const res = await fetch(`/api/vote?week=${encodeURIComponent(week)}`, { cache: "no-store" });
      const data = await res.json().catch(() => ({}));
      const top = Array.isArray(data?.top) ? data.top : [];
      const payload = { top };
      window.__abfVotesCache[k] = { exp: now + VOTES_TTL_MS, payload };
      return payload;
    }catch{
      return { top: [] };
    }
  }

  async function apiVote(trackKeyRaw, artist = "", title = ""){
    const week = getISOWeekId();
    const res = await fetch("/api/vote", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ week, track_key: trackKeyRaw, artist, title }),
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok || data?.ok === false){
      return { ok: false, status: res.status, error: data?.error || `HTTP ${res.status}`, reason: data?.reason || "" };
    }
    return { ok: true, status: res.status, week: data?.week || week, count: data?.count };
  }

  function voteErrorToast(r){
    if (r?.status === 429){
      alert("You already voted today. Come back in 24h üôÇ");
      return;
    }
    if (r?.status === 409 || r?.reason === "cooldown"){
      alert("You already voted for this track. Come back in 24h üôÇ");
      return;
    }
    alert(`Vote failed: ${r?.error || "Unknown error"}`);
  }

  function buildVoteIndex(topRows){
    const exact = Object.create(null);
    const lower = Object.create(null);
    const byNorm = Object.create(null);
    for (const row of (topRows || [])){
      const tk = String(row?.track_key || "").trim();
      const c = Number(row?.count || 0);
      if (!tk) continue;
      exact[tk] = c;
      lower[tk.toLowerCase()] = c;
      const sp = splitTrack(tk);
      const n = normKey(sp.artist, sp.title);
      if (n) byNorm[n] = c;
    }
    return {
      getCount(trackKeyRaw, artistMaybe, titleMaybe){
        const k = String(trackKeyRaw || "").trim();
        if (k && exact[k] != null) return exact[k];
        if (k && lower[k.toLowerCase()] != null) return lower[k.toLowerCase()];
        const sp = k ? splitTrack(k) : { artist: String(artistMaybe||""), title: String(titleMaybe||"") };
        const n = normKey(sp.artist, sp.title);
        if (n && byNorm[n] != null) return byNorm[n];
        return 0;
      }
    };
  }

  function toLocalKey(ts){
    const d = new Date(ts);
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    const hh = String(d.getHours()).padStart(2,"0");
    const mi = String(d.getMinutes()).padStart(2,"0");
    return { date: `${yyyy}-${mm}-${dd}`, time: `${hh}:${mi}` };
  }

  function findClosestByDateTime(history, dateStr, timeStr, toleranceMinutes = 45) {
    if (!dateStr || !timeStr) return null;
    const [y, m, d] = dateStr.split("-").map(Number);
    const [hh, mi] = timeStr.split(":").map(Number);
    if (!y || !m || !d || Number.isNaN(hh) || Number.isNaN(mi)) return null;

    // Force UTC pour coh√©rence avec timestamps serveur
    const targetUTC = Date.UTC(y, m - 1, d, hh, mi, 0, 0);
    const tol = toleranceMinutes * 60 * 1000;

    let best = null;
    let bestDelta = Infinity;
    let sameDayMatches = 0;

    for (const entry of (history || [])) {
      const ts = Number(entry?.ts || 0);
      if (!ts) continue;

      // V√©rifier si c'est le m√™me jour (UTC)
      const entryDate = new Date(ts);
      const entryUTCDate = Date.UTC(entryDate.getUTCFullYear(), entryDate.getUTCMonth(), entryDate.getUTCDate());
      const targetUTCDate = Date.UTC(y, m - 1, d);
      if (entryUTCDate !== targetUTCDate) continue; // m√™me jour seulement

      sameDayMatches++;
      const delta = Math.abs(ts - targetUTC);
      if (delta < bestDelta) {
        bestDelta = delta;
        best = entry;
      }
    }

    if (!best) {
      console.log("Recherche:", { dateStr, timeStr, targetUTC: new Date(targetUTC).toISOString(), sameDayMatches, result: "No match in the same day" });
      return null;
    }

    console.log("Recherche:", { dateStr, timeStr, targetUTC: new Date(targetUTC).toISOString(), bestTs: best.ts, bestDeltaMin: Math.round(bestDelta / 60000), sameDayMatches });

    return { best, bestDelta, within: bestDelta <= tol };
  }

  function renderAirSearchResult(root, payload){
    const box = root.querySelector("#airSearchResult");
    if (!box) return;
    box.classList.remove("hidden");
    if (!payload){
      box.innerHTML = `<div class="text-white/60 text-sm">No close match found in that day.</div>`;
      return;
    }
    const { best, bestDelta, within } = payload;
    const t = splitTrack(best.t);
    const time = fmtTime(best.ts);
    const d = toLocalKey(best.ts).date;
    const artist = upperArtist(String(t.artist || "‚Äî"));
    const title = titleCaseEN(stripTitleSuffixes(String(t.title || "‚Äî")));
    box.innerHTML = `
      <div class="rounded-2xl border border-white/10 bg-white/[0.04] p-3">
        <div class="flex items-center justify-between gap-3">
          <div class="text-xs text-white/60">
            ${within ? "Closest match found" : "Match found (time delta is large)"} ‚Ä¢
            <span class="tabular-nums">${esc(d)} ${esc(time)}</span>
          </div>
          <div class="text-xs text-white/45 tabular-nums">Œî ${Math.round(bestDelta/60000)} min</div>
        </div>
        <div class="mt-2 font-extrabold text-white truncate">${esc(artist)}</div>
        <div class="text-white/65 text-sm truncate">${esc(title)}</div>
      </div>
    `;
  }

  function bindAirSearchOnce(root){
    if (!root || state.searchBound) return;
    const dateEl = root.querySelector("#airDate");
    const timeEl = root.querySelector("#airTime");
    const btnEl = root.querySelector("#airSearchBtn");
    if (!dateEl || !timeEl || !btnEl) return;
    if (!dateEl.value){
      const n = new Date();
      const yyyy = n.getFullYear();
      const mm = String(n.getMonth() + 1).padStart(2,"0");
      const dd = String(n.getDate()).padStart(2,"0");
      dateEl.value = `${yyyy}-${mm}-${dd}`;
    }
    if (!timeEl.value){
      const n = new Date();
      timeEl.value = `${String(n.getHours()).padStart(2,"0")}:${String(n.getMinutes()).padStart(2,"0")}`;
    }
    const run = () => {
      state.search.date = dateEl.value || "";
      state.search.time = timeEl.value || "";
      const payload = findClosestByDateTime(state.lastHistory, state.search.date, state.search.time, 45);
      renderAirSearchResult(root, payload);
    };
    btnEl.addEventListener("click", run);
    dateEl.addEventListener("change", run);
    timeEl.addEventListener("change", run);
    state.searchBound = true;
    run();
  }

  function badgeTimeBlue(text){
    return `
      <span class="inline-flex items-center gap-2 px-2.5 py-1 rounded-full bg-cyan-500/10 border border-cyan-400/20 text-cyan-200 text-[11px] font-semibold tabular-nums">
        <span class="w-2 h-2 rounded-full bg-cyan-300/80"></span>
        ${esc(text || "--:--")}
      </span>
    `;
  }

  function rowHtml({ coverUrl, artist, title, time, count, blocked, voted, kNorm, kRaw, aRaw, tRaw }){
    return `
      <div class="abfHistoryRow ${voted ? "abfVotedRow" : ""} flex items-center justify-between gap-3 border border-white/10 bg-white/[0.03] hover:bg-white/[0.05] transition rounded-2xl p-3">
        <div class="flex items-center gap-3 min-w-0 flex-1">
          ${coverHtmlByUrl(coverUrl)}
          <div class="min-w-0 flex-1">
            <div class="flex items-center justify-between gap-3">
              <div class="font-extrabold text-white truncate">${esc(artist || "‚Äî")}</div>
              ${badgeTimeBlue(time)}
            </div>
            <div class="text-white/65 text-sm truncate">${esc(title || "‚Äî")}</div>
          </div>
        </div>
        <button
          class="voteBtn flex-none bg-white/5 hover:bg-white/10 border border-white/10 rounded-2xl px-3 py-2 text-sm text-white/85 transition"
          data-norm="${esc(kNorm)}"
          data-raw="${esc(kRaw)}"
          data-artist="${esc(aRaw || "")}"
          data-title="${esc(tRaw || "")}"
          data-blocked="${blocked ? "1" : "0"}"
          data-voted="${voted ? "1" : "0"}"
          type="button"
          aria-label="Vote"
          title="${blocked ? "Voting disabled for ABF CLUB" : (voted ? "Already voted today" : "Vote")}"
          style="${(blocked || voted) ? "opacity:0.55;cursor:not-allowed;" : ""}"
        >
          üëç <span class="voteCount tabular-nums">${esc(String(count ?? 0))}</span>
        </button>
      </div>
    `;
  }

  function rankBadgeClass(rank){
    if (rank === 1) return "bg-amber-400/15 border-amber-300/30 text-amber-200";
    if (rank === 2) return "bg-slate-200/10 border-slate-200/25 text-slate-100";
    if (rank === 3) return "bg-orange-400/15 border-orange-300/30 text-orange-200";
    return "bg-cyan-500/10 border-cyan-400/20 text-cyan-100";
  }

  function chartRowHtml(rank, coverUrl, artist, title, count, max){
    const pct = Math.round((Number(count) / Math.max(1, Number(max))) * 100);
    return `
      <li class="group flex items-center gap-4 p-4 rounded-3xl border border-white/10 bg-white/[0.03] hover:bg-white/[0.05] transition">
        <div class="flex-none w-10 h-10 rounded-2xl border ${rankBadgeClass(rank)} flex items-center justify-center text-sm font-extrabold tabular-nums">
          ${rank}
        </div>
        ${coverHtmlByUrl(coverUrl)}
        <div class="min-w-0 flex-1">
          <div class="flex items-start gap-3">
            <div class="min-w-0">
              <div class="font-extrabold text-white truncate">${esc(artist)}</div>
              <div class="text-white/65 text-sm truncate">${esc(title)}</div>
            </div>
            <div class="ml-auto flex-none text-sm text-white/90 font-extrabold tabular-nums">
              ${esc(String(count))} <span class="text-white/50 font-normal">votes</span>
            </div>
          </div>
          <div class="mt-3 h-2 rounded-full bg-white/5 border border-white/10 overflow-hidden">
            <div class="h-full bg-gradient-to-r from-[#145C8F] to-[#2FC2FF]" style="width:${pct}%"></div>
          </div>
        </div>
      </li>
    `;
  }

  async function render(){
    if (!isMusicRoute()) return;
    const root = getRoot();
    if (!root) return;
    if (state.inFlight) return;
    state.inFlight = true;
    try{
      const artistEl = root.querySelector("#musicArtist");
      const titleEl = root.querySelector("#musicTitle");
      const timeEl = root.querySelector("#musicTime");
      const histEl = root.querySelector("#historyTable");
      const histEmpty= root.querySelector("#historyEmpty");
      const nowVoteBtn = root.querySelector("#nowVoteBtn");
      const nowVoteCount = root.querySelector("#nowVoteCount");
      const weekThisEl = root.querySelector("#weekThis");
      const weekPrevEl = root.querySelector("#weekPrev");
      const topThisEl = root.querySelector("#topThisWeek");
      const topPrevEl = root.querySelector("#topPrevWeek");
      const topThisEmpty = root.querySelector("#topThisEmpty");
      const topPrevEmpty = root.querySelector("#topPrevEmpty");
      const week = getISOWeekId();
      const prevWeek = getPrevISOWeekId();
      if (weekThisEl) weekThisEl.textContent = week.replace("-W"," W");
      if (weekPrevEl) weekPrevEl.textContent = prevWeek.replace("-W"," W");
      if (!artistEl || !titleEl || !histEl || !topThisEl || !topPrevEl) return;
      let history = await fetchServerNowPlaying(80);
      if (!history.length) history = loadHistory();
      state.lastHistory = history || [];
      if (!history.length){
        artistEl.textContent = "‚Äî";
        titleEl.textContent = "‚Äî";
        if (timeEl) timeEl.textContent = "--:--";
        setCover("", root);
        setCoverSourceBadge(root, "", "");
        if (histEmpty) histEmpty.classList.remove("hidden");
        histEl.innerHTML = "";
        if (nowVoteBtn) nowVoteBtn.style.display = "none";
        if (topThisEmpty) topThisEmpty.classList.remove("hidden");
        if (topPrevEmpty) topPrevEmpty.classList.remove("hidden");
        topThisEl.innerHTML = "";
        topPrevEl.innerHTML = "";
        return;
      }
      if (histEmpty) histEmpty.classList.add("hidden");
      const coverByNorm = {};
      for (const entry of history){
        const t = splitTrack(entry.t);
        const n = normKey(t.artist, t.title);
        const u = String(entry.cover_url || "").trim();
        if (n && u) coverByNorm[n] = u;
      }
      const currentEntry = history[0];
      const current = splitTrack(currentEntry.t);
      const nowArtistRaw = String(current.artist || "").trim();
      const nowTitleRaw0 = String(current.title || "").trim();
      const nowTitleClean = stripTitleSuffixes(nowTitleRaw0);
      artistEl.textContent = upperArtist(nowArtistRaw || "‚Äî");
      titleEl.textContent = titleCaseEN(nowTitleClean || "‚Äî");
      const nowTime = fmtTime(currentEntry.ts);
      if (timeEl) timeEl.textContent = nowTime;
      const nowCover =
        String(currentEntry.cover_url || "").trim() ||
        (coverByNorm[normKey(nowArtistRaw, nowTitleRaw0)] || "");
      setCover(nowCover, root);
      setCoverSourceBadge(root, nowCover, String(currentEntry.cover_source || ""));
      const [{ top: topThis }, { top: topPrev }] = await Promise.all([
        apiGetTopWeek(week),
        apiGetTopWeek(prevWeek),
      ]);
      const voteIndex = buildVoteIndex(topThis || []);
      // NOW vote
      const nowKNorm = normKey(nowArtistRaw, nowTitleRaw0);
      const nowKRaw = rawKey(nowArtistRaw, nowTitleRaw0);
      const nowCount = voteIndex.getCount(nowKRaw, nowArtistRaw, nowTitleRaw0);
      const nowBlocked = isBlockedShow(nowArtistRaw);
      const nowAlready = isVoted(nowKNorm);
      if (nowVoteCount) nowVoteCount.textContent = String(nowCount);
      if (nowVoteBtn){
        nowVoteBtn.style.display = "inline-flex";
        if (nowBlocked || nowAlready){
          nowVoteBtn.classList.add("is-voted");
          nowVoteBtn.style.opacity = "0.55";
          nowVoteBtn.style.cursor = "not-allowed";
        } else {
          nowVoteBtn.classList.remove("is-voted");
          nowVoteBtn.style.opacity = "1";
          nowVoteBtn.style.cursor = "pointer";
        }
        nowVoteBtn.dataset.raw = nowKRaw;
        nowVoteBtn.dataset.norm = nowKNorm;
        nowVoteBtn.dataset.artist = nowArtistRaw;
        nowVoteBtn.dataset.title = nowTitleRaw0;
        nowVoteBtn.dataset.blocked = nowBlocked ? "1" : "0";
        if (!nowVoteBtn.dataset.listenerAttached){
          nowVoteBtn.dataset.listenerAttached = "true";
          nowVoteBtn.addEventListener("click", async () => {
            const root = getRoot();
            if (!root) return;
            const btn = root.querySelector("#nowVoteBtn");
            if (!btn) return;
            const blocked = btn.dataset.blocked === "1";
            const kNorm = btn.dataset.norm || "";
            const kRaw = btn.dataset.raw || "";
            const a = btn.dataset.artist || "";
            const t = btn.dataset.title || "";
            if (blocked){
              blockedVoteMsg();
              return;
            }
            if (isVoted(kNorm)){
              alert("You already voted for this track. Come back in 24h üôÇ");
              btn.classList.add("is-voted");
              btn.style.opacity = "0.55";
              btn.style.cursor = "not-allowed";
              return;
            }
            btn.style.opacity = "0.7";
            btn.style.cursor = "wait";
            const r = await apiVote(kRaw, a, t);
            if (!r.ok){
              btn.style.opacity = "1";
              btn.style.cursor = "pointer";
              voteErrorToast(r);
              return;
            }
            markVoted(kNorm);
            const ck = votesCacheKey(getISOWeekId());
            if (window.__abfVotesCache?.[ck]) window.__abfVotesCache[ck].exp = 0;
            btn.classList.add("is-voted");
            btn.style.opacity = "0.55";
            btn.style.cursor = "not-allowed";
            render();
          });
        }
      }
      // LAST PLAYED - 18 titres
      const limit = 18;
      const rows = history.slice(1, 1 + limit);
      histEl.innerHTML = rows.map((entry) => {
        const t = splitTrack(entry.t);
        const aRaw = String(t.artist || "").trim();
        const tRaw0 = String(t.title || "").trim();
        const tClean = stripTitleSuffixes(tRaw0);
        const kNorm = normKey(aRaw, tRaw0);
        const kRaw = rawKey(aRaw, tRaw0);
        const coverUrl =
          String(entry.cover_url || "").trim() ||
          (coverByNorm[normKey(aRaw, tRaw0)] || "");
        const count = voteIndex.getCount(kRaw, aRaw, tRaw0);
        const blocked = isBlockedShow(aRaw);
        const voted = isVoted(kNorm);
        return rowHtml({
          coverUrl,
          artist: upperArtist(aRaw || "‚Äî"),
          title: titleCaseEN(tClean || "‚Äî"),
          time: fmtTime(entry.ts),
          count,
          blocked,
          voted,
          kNorm,
          kRaw,
          aRaw,
          tRaw: tRaw0
        });
      }).join("");
      // wire vote buttons
      histEl.querySelectorAll(".voteBtn").forEach((btn) => {
        const kNorm = btn.dataset.norm || "";
        const kRaw = btn.dataset.raw || "";
        const a = btn.dataset.artist || "";
        const t0 = btn.dataset.title || "";
        const blocked = btn.dataset.blocked === "1";
        const countEl = btn.querySelector(".voteCount");
        const c = voteIndex.getCount(kRaw, a, t0);
        if (countEl) countEl.textContent = String(c);
        const row = btn.closest(".abfHistoryRow");
        const already = isVoted(kNorm);
        if (blocked || already){
          btn.classList.add("is-voted");
          btn.style.opacity = "0.55";
          btn.style.cursor = "not-allowed";
          if (row) row.classList.add("abfVotedRow");
          btn.onclick = blocked ? blockedVoteMsg : () => {
            alert("You already voted for this track. Come back in 24h üôÇ");
          };
        } else {
          btn.classList.remove("is-voted");
          btn.style.opacity = "1";
          btn.style.cursor = "pointer";
          if (row) row.classList.remove("abfVotedRow");
          btn.onclick = async () => {
            if (isVoted(kNorm)){
              alert("You already voted for this track. Come back in 24h üôÇ");
              btn.classList.add("is-voted");
              btn.style.opacity = "0.55";
              btn.style.cursor = "not-allowed";
              if (row) row.classList.add("abfVotedRow");
              return;
            }
            btn.style.opacity = "0.7";
            btn.style.cursor = "wait";
            const r = await apiVote(kRaw || rawKey(a, t0), a, t0);
            if (!r.ok){
              btn.style.opacity = "1";
              btn.style.cursor = "pointer";
              voteErrorToast(r);
              return;
            }
            markVoted(kNorm);
            const ck = votesCacheKey(week);
            if (window.__abfVotesCache?.[ck]) window.__abfVotesCache[ck].exp = 0;
            btn.classList.add("is-voted");
            btn.style.opacity = "0.55";
            btn.style.cursor = "not-allowed";
            if (row) row.classList.add("abfVotedRow");
            render();
          };
        }
      });
      // charts this week
      const topThisSafe = (topThis || [])
        .filter(x => x && x.track_key && !isBlockedShow(String(x.artist || "")))
        .slice(0, 10);
      if (!topThisSafe.length){
        if (topThisEmpty) topThisEmpty.classList.remove("hidden");
        topThisEl.innerHTML = "";
      } else {
        if (topThisEmpty) topThisEmpty.classList.add("hidden");
        const max = Math.max(...topThisSafe.map(x => Number(x.count || 0)), 1);
        topThisEl.innerHTML = topThisSafe.map((row, idx) => {
          const tk = String(row.track_key || "");
          const sp = splitTrack(tk);
          const aRaw = String(row.artist || "").trim() || sp.artist || "‚Äî";
          const tRaw = String(row.title || "").trim() || sp.title || "‚Äî";
          const coverUrl = String(row.cover_url || "").trim() || (coverByNorm[normKey(sp.artist, sp.title)] || "");
          return chartRowHtml(idx + 1, coverUrl, upperArtist(aRaw), titleCaseEN(stripTitleSuffixes(tRaw)), Number(row.count || 0), max);
        }).join("");
      }
      // charts prev week top 5
      const topPrevSafe = (topPrev || [])
        .filter(x => x && x.track_key && !isBlockedShow(String(x.artist || "")))
        .slice(0, 5);
      if (!topPrevSafe.length){
        if (topPrevEmpty) topPrevEmpty.classList.remove("hidden");
        topPrevEl.innerHTML = "";
      } else {
        if (topPrevEmpty) topPrevEmpty.classList.add("hidden");
        const maxP = Math.max(...topPrevSafe.map(x => Number(x.count || 0)), 1);
        topPrevEl.innerHTML = topPrevSafe.map((row, idx) => {
          const tk = String(row.track_key || "");
          const sp = splitTrack(tk);
          const aRaw = String(row.artist || "").trim() || sp.artist || "‚Äî";
          const tRaw = String(row.title || "").trim() || sp.title || "‚Äî";
          const coverUrl = String(row.cover_url || "").trim() || (coverByNorm[normKey(sp.artist, sp.title)] || "");
          return chartRowHtml(idx + 1, coverUrl, upperArtist(aRaw), titleCaseEN(stripTitleSuffixes(tRaw)), Number(row.count || 0), maxP);
        }).join("");
      }
      // search refresh
      if (state.search?.date && state.search?.time){
        const payload = findClosestByDateTime(state.lastHistory, state.search.date, state.search.time, 45);
        renderAirSearchResult(root, payload);
      }
      state.lastRenderAt = nowTs();
    } finally {
      state.inFlight = false;
    }
  }

  function stopTimer(){
    if (state.timer) clearInterval(state.timer);
    state.timer = null;
  }

  function startTimer(){
    stopTimer();
    state.timer = setInterval(() => {
      if (state.inFlight) return;
      render();
    }, 8000);
  }

  function init(){
    if (!isMusicRoute()) return;
    const root = getRoot();
    if (!root) return;
    bindAirSearchOnce(root);
    render();
    startTimer();
  }

  if (!state.bound){
    state.bound = true;
    document.addEventListener("astro:page-load", init);
    document.addEventListener("astro:after-swap", init);
    document.addEventListener("astro:before-swap", () => {
      stopTimer();
    });
    window.addEventListener("abf:history-updated", () => {
      if (!isMusicRoute()) return;
      render();
    });
    window.addEventListener("resize", () => {
      if (!isMusicRoute()) return;
      const t = nowTs();
      if (t - state.lastRenderAt > 400) render();
    });
  }
  init();
})();
    </script>
  </div>
</Base>